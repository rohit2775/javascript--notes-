
  ####### all array methods ....... 
 

1. Array Creation & Checking
ðŸ”¹ Array.isArray(value)

Use: Checks whether the given value is an array or not.
Useful because in JavaScript, many things are objects, so this confirms if itâ€™s an actual array.

Array.isArray([1,2,3]); // true âœ…
Array.isArray("Rohit"); // false âŒ


ðŸ“˜ Use case: When you receive data from API or user input and want to ensure itâ€™s an array.

ðŸ”¹ Array.from(object)

Use: Converts array-like or iterable objects (like strings, NodeList, Set, etc.) into a real array.

Array.from("Rohit"); 
// Output: ['R','o','h','i','t']


ðŸ“˜ Use case:
When you select multiple DOM elements (document.querySelectorAll()), it returns NodeList (not an array).
Use Array.from() to convert it so you can use map(), filter(), etc.

ðŸ”¹ Array.of(...items)

Use: Creates a new array from the provided arguments.

Array.of(1,2,3); 
// Output: [1,2,3]


ðŸ“˜ Use case:
When you want to dynamically create an array from a list of values.

âž• 2. Add / Remove Elements
ðŸ”¹ push(element)

Use: Adds an element to the end of the array.

let arr = [1,2];
arr.push(3);
console.log(arr); // [1,2,3]


ðŸ“˜ Real-life example: Adding an item to a shopping cart.

ðŸ”¹ pop()

Use: Removes the last element from the array.

arr.pop();
console.log(arr); // [1,2]


ðŸ“˜ Real-life example: Removing the last item added to a cart.

ðŸ”¹ unshift(element)

Use: Adds an element to the start of the array.

arr.unshift(0);
console.log(arr); // [0,1,2]


ðŸ“˜ Real-life example: Adding a person at the start of a queue.

ðŸ”¹ shift()

Use: Removes the first element from the array.

arr.shift();
console.log(arr); // [1,2]


ðŸ“˜ Real-life example: Serving the first person in a queue.

ðŸ”¹ splice(start, deleteCount, ...items)

Use: Can add, remove, or replace elements at any position.
âš ï¸ This modifies the original array.

let arr2 = [1,2,3,4];
arr2.splice(1,2,99); 
console.log(arr2); // [1,99,4]


Explanation:

1 â†’ start index

2 â†’ number of elements to delete

99 â†’ element to insert

ðŸ”¹ slice(start, end)

Use: Returns a copy of a portion of an array (does not change original).

let newArr = [10,20,30,40].slice(1,3);
console.log(newArr); // [20,30]


ðŸ“˜ Use case: Getting a part of an array for pagination.

ðŸ”¹ concat()

Use: Combines two or more arrays into a new array.

let merged = [1,2].concat([3,4]);
console.log(merged); // [1,2,3,4]


ðŸ“˜ Use case: Combining different sets of data.

ðŸ” 3. Searching & Checking Elements
ðŸ”¹ indexOf(value)

Use: Returns the first index of the element. Returns -1 if not found.

[1,2,3,2].indexOf(2); // 1

ðŸ”¹ lastIndexOf(value)

Use: Returns the last index of the element.

[1,2,3,2].lastIndexOf(2); // 3

ðŸ”¹ includes(value)

Use: Checks if the element exists in the array. Returns true/false.

[1,2,3].includes(2); // true


ðŸ“˜ Use case: Validating if a user input or value already exists.

ðŸ”¹ find(callback)

Use: Returns the first element that satisfies a condition.

let num = [10,20,30].find(x => x > 15);
console.log(num); // 20

ðŸ”¹ findIndex(callback)

Use: Returns the index of the first element that satisfies a condition.

[10,20,30].findIndex(x => x > 15); // 1

ðŸ”¹ every(callback)

Use: Checks if all elements satisfy the condition.

[2,4,6].every(x => x % 2 === 0); // true

ðŸ”¹ some(callback)

Use: Checks if any element satisfies the condition.

[1,2,3].some(x => x > 2); // true

ðŸ” 4. Looping / Iteration
ðŸ”¹ forEach(callback)

Use: Executes a function for each element, but does not return anything.

[1,2,3].forEach(x => console.log(x * 2));

ðŸ”¹ map(callback)

Use: Applies a function on each element and returns a new array.

let doubled = [1,2,3].map(x => x * 2);
console.log(doubled); // [2,4,6]

ðŸ”¹ filter(callback)

Use: Returns a new array of elements that satisfy a condition.

let even = [1,2,3,4].filter(x => x % 2 === 0);
console.log(even); // [2,4]

ðŸ”¹ reduce(callback, initialValue)

Use: Combines all elements into a single value.

let sum = [1,2,3,4].reduce((total, x) => total + x, 0);
console.log(sum); // 10


ðŸ“˜ Real-life: Calculating total price in a cart.

ðŸ”¹ reduceRight(callback)

Use: Same as reduce, but runs from right to left.

[1,2,3].reduceRight((a,b)=>a-b); // 0

ðŸ”„ 5. Sorting / Reversing
ðŸ”¹ sort(compareFn)

Use: Sorts elements of an array. Default is string sorting, so for numbers, use a compare function.

let nums = [40,10,30];
nums.sort((a,b) => a - b);
console.log(nums); // [10,30,40]

ðŸ”¹ reverse()

Use: Reverses the order of elements.

[1,2,3].reverse(); // [3,2,1]



 if want  to better understand in hindi .... 



 1. Array Creation & Checking
ðŸ”¹ Array.isArray(value)

Use: Ye check karta hai ki jo value di gayi hai wo array hai ya nahi.
Kyunki JS me sab kuch object hota hai, isse sure karne ke liye ye method use hota hai.

Array.isArray([1,2,3]); // true  âœ… ye ek array hai
Array.isArray("Rohit"); // false âŒ ye ek string hai


ðŸ“˜ Use case:
Jab API ya user se data mile, aur tumhe check karna ho ki wo array hai ya single value.

ðŸ”¹ Array.from(object)

Use: Ye kisi bhi array-like ya iterable object (like string, NodeList, Set, etc.) ko array me convert karta hai.

Array.from("Rohit"); 
// Output: ['R','o','h','i','t']


ðŸ“˜ Use case:
DOM me jab hum document.querySelectorAll() se NodeList nikalte hain, wo array nahi hota.
Use Array.from() se array me convert karte hain taaki hum map(), filter() use kar sakein.

ðŸ”¹ Array.of(...items)

Use: Ye given arguments se ek naya array banata hai.

Array.of(1,2,3); 
// Output: [1,2,3]


ðŸ“˜ Use case:
Jab hume dynamically elements se array banana ho bina kisi type confusion ke.

âž• 2. Add / Remove Elements
ðŸ”¹ push(element)

Use: Ye array ke end me ek element add karta hai.

let arr = [1,2];
arr.push(3);
console.log(arr); // [1,2,3]


ðŸ“˜ Real-life: Shopping cart me item add karna.

ðŸ”¹ pop()

Use: Ye last element remove karta hai.

arr.pop();
console.log(arr); // [1,2]


ðŸ“˜ Real-life: Cart se last added product remove karna.

ðŸ”¹ unshift(element)

Use: Ye array ke start me element add karta hai.

arr.unshift(0);
console.log(arr); // [0,1,2]


ðŸ“˜ Real-life: Queue ke starting me new entry lagana.

ðŸ”¹ shift()

Use: Ye first element remove karta hai.

arr.shift();
console.log(arr); // [1,2]


ðŸ“˜ Real-life: Queue ke first person ko remove karna (kaam ho gaya ðŸ˜„).

ðŸ”¹ splice(start, deleteCount, ...items)

Use: Ye elements ko remove, replace ya add kar sakta hai.
âš ï¸ Original array change karta hai.

let arr2 = [1,2,3,4];
arr2.splice(1,2,99); 
console.log(arr2); // [1,99,4]


ðŸ“˜ Explanation:

1 â†’ start index

2 â†’ deleteCount

99 â†’ new element
So index 1 aur 2 delete hue (2,3) aur 99 add hua.

ðŸ”¹ slice(start, end)

Use: Array ke ek portion ka copy return karta hai (original change nahi hoti).

let newArr = [10,20,30,40].slice(1,3);
console.log(newArr); // [20,30]


ðŸ“˜ Use case: Jab array ka ek part chahiye ho â€” jaise pagination me.

ðŸ”¹ concat()

Use: 2 ya zyada arrays ko combine karta hai.

let merged = [1,2].concat([3,4]);
console.log(merged); // [1,2,3,4]


ðŸ“˜ Use case: Different arrays ka combined data chahiye.

ðŸ” 3. Searching & Checking Elements
ðŸ”¹ indexOf(value)

Use: Element ka first index batata hai. Agar nahi milta to -1.

[1,2,3,2].indexOf(2); // 1

ðŸ”¹ lastIndexOf(value)

Use: Element ka last index batata hai.

[1,2,3,2].lastIndexOf(2); // 3

ðŸ”¹ includes(value)

Use: Check karta hai ki array me wo value hai ya nahi (true/false).

[1,2,3].includes(2); // true


ðŸ“˜ Use case: Validation ke liye â€” e.g. check if user input already exists.

ðŸ”¹ find(callback)

Use: Pehla element return karta hai jo condition ko satisfy karta hai.

let num = [10,20,30].find(x => x > 15);
console.log(num); // 20

ðŸ”¹ findIndex(callback)

Use: Pehle matching element ka index return karta hai.

[10,20,30].findIndex(x => x > 15); // 1

ðŸ”¹ every(callback)

Use: Check karta hai sabhi elements condition pass kar rahe hain ya nahi.

[2,4,6].every(x => x % 2 === 0); // true

ðŸ”¹ some(callback)

Use: Check karta hai ki koi ek element bhi condition pass karta hai ya nahi.

[1,2,3].some(x => x > 2); // true

ðŸ” 4. Looping / Iteration
ðŸ”¹ forEach(callback)

Use: Har element par function execute karta hai, but return nahi karta.

[1,2,3].forEach(x => console.log(x * 2));

ðŸ”¹ map(callback)

Use: Har element par function apply karta hai aur new array return karta hai.

let doubled = [1,2,3].map(x => x * 2);
console.log(doubled); // [2,4,6]

ðŸ”¹ filter(callback)

Use: Jo elements condition pass karte hain, unka naya array banata hai.

let even = [1,2,3,4].filter(x => x % 2 === 0);
console.log(even); // [2,4]

ðŸ”¹ reduce(callback, initialValue)

Use: Array ke sabhi elements ko combine karke ek single value return karta hai.

let sum = [1,2,3,4].reduce((total, x) => total + x, 0);
console.log(sum); // 10


ðŸ“˜ Real-life: Bill me total price calculate karna.

ðŸ”¹ reduceRight(callback)

Use: Same as reduce, lekin right to left kaam karta hai.

[1,2,3].reduceRight((a,b)=>a-b); // 0

ðŸ”„ 5. Sorting / Reversing
ðŸ”¹ sort(compareFn)

Use: Array ke elements ko sort karta hai (default string wise).
Numerical sorting ke liye compareFn zaroor likhna hota hai.

let nums = [40,10,30];
nums.sort((a,b) => a - b);
console.log(nums); // [10,30,40]

ðŸ”¹ reverse()

Use: Array ko ulta kar deta hai.

[1,2,3].reverse(); // [3,2,1]




 ####### objects in js 

 What is an Object?

English:
An object is a collection of key-value pairs.
Keys are usually strings (or symbols), and values can be anything: numbers, strings, arrays, functions, or even other objects.
Objects allow you to group related data together.

let student = {
    name: "Rohit",
    age: 18,
    marks: [85, 90, 95],
    isActive: true
};



2ï¸âƒ£ Accessing Properties

Dot Notation

console.log(student.name); // "Rohit"


Bracket Notation (useful when key is dynamic)

console.log(student["age"]); // 18

let key = "marks";
console.log(student[key]); // [85, 90, 95]

3ï¸âƒ£ Adding or Updating Properties
// Add a new property
student.gender = "Male";

// Update existing property
student.age = 19;

console.log(student);
// { name: 'Rohit', age: 19, marks: [85,90,95], isActive: true, gender: 'Male' }

4ï¸âƒ£ Deleting Properties
delete student.isActive;
console.log(student);
// { name: 'Rohit', age: 19, marks: [85,90,95], gender: 'Male' }

5ï¸âƒ£ Methods in Objects

English: Methods are functions inside objects. They usually operate on the objectâ€™s data using this.

let student = {
    name: "Rohit",
    age: 18,
    greet: function() {
        console.log(`Hello, my name is ${this.name}`);
    }
};

student.greet(); // "Hello, my name is Rohit"


6ï¸âƒ£ Built-in Object Methods
1. Object.keys(obj) â†’ Returns all keys
console.log(Object.keys(student)); // ["name","age","greet"]

2. Object.values(obj) â†’ Returns all values
console.log(Object.values(student)); // ["Rohit", 18, function greet(){}]

3. Object.entries(obj) â†’ Returns array of [key, value] pairs
console.log(Object.entries(student));
// [["name","Rohit"], ["age",18], ["greet", function(){}]]

4. Object.assign(target, ...sources) â†’ Copies properties from sources to target
let obj1 = {a:1, b:2};
let obj2 = {b:3, c:4};
Object.assign(obj1, obj2);
console.log(obj1); // {a:1, b:3, c:4}

5. Object.freeze(obj) â†’ Makes object immutable (cannot add/update/delete)
Object.freeze(student);
student.age = 20; // won't work
student.city = "Delhi"; // won't work

6. Object.seal(obj) â†’ Allows modifying existing properties but cannot add/delete
Object.seal(student);
student.age = 25; // works
student.city = "Delhi"; // doesn't work

7. Object.hasOwn(obj, prop) â†’ Checks if object has its own property (not inherited)
console.log(Object.hasOwn(student, 'name')); // true
console.log(Object.hasOwn(student, 'toString')); // false

8. Object.getOwnPropertyNames(obj) â†’ Returns all property names (enumerable + non-enumerable)
console.log(Object.getOwnPropertyNames(student));

7ï¸âƒ£ Looping through Objects
for (let key in student) {
    console.log(key, student[key]);
}
// name Rohit
// age 18
// greet function()...

8ï¸âƒ£ Mini Example
let student = {
    name: "Rohit",
    age: 18,
    marks: [85,90],
    greet() { console.log(`Hi, I'm ${this.name}`); }
};

// Access
console.log(student.name);

// Add / Update
student.gender = "Male";
student.age = 19;

// Delete
delete student.marks;

// Object methods
console.log(Object.keys(student)); // ['name','age','greet','gender']
console.log(Object.values(student)); // ['Rohit',19,function,'Male']

// Loop
for(let key in student) {
    console.log(key, student[key]);
}

// Method call
student.greet(); // Hi, I'm Rohit



 now  lets understand in hindi 


 Object kya hai?

Hindi:
Object ek key-value pair ka collection hota hai.
Keys usually strings (ya symbols) hoti hain, aur values kuch bhi ho sakti hain: numbers, strings, arrays, functions, ya dusre objects.
Objects hume related data ko ek saath organize karne me help karte hain.

let student = {
    name: "Rohit",
    age: 18,
    marks: [85, 90, 95],
    isActive: true
};

2ï¸âƒ£ Object ki properties access karna

Dot Notation / Dot se access

console.log(student.name); // "Rohit"


Bracket Notation / Brackets se access (jab key dynamic ho)

console.log(student["age"]); // 18

let key = "marks";
console.log(student[key]); // [85, 90, 95]

3ï¸âƒ£ Properties add ya update karna
// Nayi property add karna
student.gender = "Male";

// Existing property update karna
student.age = 19;

console.log(student);
// { name: 'Rohit', age: 19, marks: [85,90,95], isActive: true, gender: 'Male' }

4ï¸âƒ£ Properties delete karna
delete student.isActive;
console.log(student);
// { name: 'Rohit', age: 19, marks: [85,90,95], gender: 'Male' }

5ï¸âƒ£ Object Methods / Object me functions

Hindi: Methods wo functions hote hain jo object ke andar define hote hain.

Usually this ka use object ke data ko access karne ke liye hota hai.

let student = {
    name: "Rohit",
    age: 18,
    greet: function() {
        console.log(`Hello, mera naam hai ${this.name}`);
    }
};

student.greet(); // "Hello, mera naam hai Rohit"

6ï¸âƒ£ Built-in Object Methods / Inbuilt methods
1ï¸âƒ£ Object.keys(obj) â†’ Sab keys ka array return karta hai
console.log(Object.keys(student)); // ["name","age","greet"]

2ï¸âƒ£ Object.values(obj) â†’ Sab values ka array return karta hai
console.log(Object.values(student)); // ["Rohit", 18, function greet(){}]

3ï¸âƒ£ Object.entries(obj) â†’ [key, value] pairs ka array return karta hai
console.log(Object.entries(student));
// [["name","Rohit"], ["age",18], ["greet", function(){}]]

4ï¸âƒ£ Object.assign(target, ...sources) â†’ Ek ya zyada source objects ki properties target me copy karta hai
let obj1 = {a:1, b:2};
let obj2 = {b:3, c:4};
Object.assign(obj1, obj2);
console.log(obj1); // {a:1, b:3, c:4}

5ï¸âƒ£ Object.freeze(obj) â†’ Object ko immutable bana deta hai (add/update/delete nahi kar sakte)
Object.freeze(student);
student.age = 20; // kaam nahi karega
student.city = "Delhi"; // kaam nahi karega

6ï¸âƒ£ Object.seal(obj) â†’ Existing properties modify kar sakte ho, lekin new property add/delete nahi kar sakte
Object.seal(student);
student.age = 25; // kaam karega
student.city = "Delhi"; // kaam nahi karega

7ï¸âƒ£ Object.hasOwn(obj, prop) â†’ Check karta hai ki property object ki apni hai ya inherited
console.log(Object.hasOwn(student, 'name')); // true
console.log(Object.hasOwn(student, 'toString')); // false

8ï¸âƒ£ Object.getOwnPropertyNames(obj) â†’ Sab property names (enumerable + non-enumerable) ka array return karta hai
console.log(Object.getOwnPropertyNames(student));

7ï¸âƒ£ Object loop / Object me loop lagana
for (let key in student) {
    console.log(key, student[key]);
}
// name Rohit
// age 18
// greet function()...

8ï¸âƒ£ Mini Example â€” Objects + Methods
let student = {
    name: "Rohit",
    age: 18,
    marks: [85,90],
    greet() { console.log(`Hi, mai ${this.name} hu`); }
};

// Access
console.log(student.name);

// Add / Update
student.gender = "Male";
student.age = 19;

// Delete
delete student.marks;

// Object methods
console.log(Object.keys(student)); // ['name','age','greet','gender']
console.log(Object.values(student)); // ['Rohit',19,function,'Male']

// Loop
for(let key in student) {
    console.log(key, student[key]);
}

// Method call
student.greet(); // Hi, mai Rohit hu




.. #### import and export 

   What are import and export in JavaScript?

When we build big projects, we split our code into multiple files so that everything stays clean, readable, and easy to manage.
This is called modular coding.

Now, if you write a function, variable, or class in one file
and want to use it in another file,
youâ€™ll use export (to send it out) and import (to bring it in).

ðŸ”¹ 1. Export â€” sending code out of a file
(a) Named Export

You can export multiple things from a file, each with its own name.

// file: math.js
export const PI = 3.14;

export function add(a, b) {
  return a + b;
}

export function subtract(a, b) {
  return a - b;
}


Now, to use them in another file ðŸ‘‡

// file: app.js
import { PI, add, subtract } from './math.js';

console.log(PI); // 3.14
console.log(add(5, 3)); // 8
console.log(subtract(5, 3)); // 2


The curly braces {} mean youâ€™re importing named exports by their names.

(b) Default Export

If you want to export only one main thing from a file,
use export default.

// file: greet.js
export default function greet(name) {
  return `Hello, ${name}!`;
}


Now import it ðŸ‘‡

// file: app.js
import greet from './greet.js';

console.log(greet('Rohit')); // Hello, Rohit!


âš¡ Here, you donâ€™t need {} because itâ€™s a default export.

ðŸ”¹ 2. Import â€” bringing code into a file

When you want to use code from another file, you import it.

Example ðŸ‘‡

import { add } from './math.js';
import greet from './greet.js';

console.log(add(2, 3)); // 5
console.log(greet('Rohit')); // Hello, Rohit!

ðŸ§  Important Tips to Remember
Type	           Syntax	                          Example
Named Export	   export const name = ...	             export function add() {}
Default Export	   export default ...	                 export default function() {}
Named Import	   import { name } from '...'	         import { add } from './math.js'
Default Import	   import name from '...'	             import greet from './greet.js'
Rename Import	   import { add as plus } from '...'	  plus(2, 3)


ðŸ“¦ Real-World Example

Letâ€™s say you have a utils.js file that contains some useful functions ðŸ‘‡

// utils.js
export function formatName(name) {
  return name.toUpperCase();
}

export default function sayHi(name) {
  console.log(`Hi, ${name}!`);
}


Now you can import and use them in your main file ðŸ‘‡

// main.js
import sayHi, { formatName } from './utils.js';

const name = formatName('rohit');
sayHi(name); // Hi, ROHIT!


In simple words ðŸ‘‡

ðŸ”¸ export = send something out of a file
ðŸ”¸ import = bring something into a file




  lets get started with the asynchronous javascript 

    for andeling API's delays, and  fretching data we have to use asynchronous javascript 
    like promises , async await etc 


    setTimeout() and setInterval()
    Promise (resolve, reject, then, catch)
    async / await
    fetch() API (for making requests)


    setTimeout()

What it does:
setTimeout() runs a piece of code after a delay (in milliseconds) â€” and it runs only once.

Example:
console.log("Start");

setTimeout(() => {
  console.log("Hello Rohit after 2 seconds!");
}, 2000); // 2000 ms = 2 seconds

console.log("End");

Output:
Start
End
Hello Rohit after 2 seconds!


ðŸ§  Explanation:
setTimeout() is asynchronous â€” it doesnâ€™t block other code.
The rest of the program continues running, and after the given delay, your callback runs.

ðŸ” 2. setInterval()

What it does:
setInterval() repeatedly runs a function every X milliseconds until you stop it.

Example:
let count = 0;

const intervalId = setInterval(() => {
  count++;
  console.log("Count:", count);

  if (count === 5) {
    clearInterval(intervalId); // stop after 5 times
  }
}, 1000); // run every 1 second

Output:
Count: 1
Count: 2
Count: 3
Count: 4
Count: 5


ðŸ§  Explanation:

setInterval() runs repeatedly

Use clearInterval(id) to stop it.

ðŸ’Ž 3. Promise

What it does:
A Promise is an object that represents a value that may be available now, later, or never.
Itâ€™s used to handle asynchronous tasks like API calls or reading files.

A Promise has 3 states:

pending

fulfilled (resolved)

rejected

Example:
let myPromise = new Promise((resolve, reject) => {
  let success = true; // try changing to false to test rejection

  if (success) {
    resolve("âœ… Task done successfully!");
  } else {
    reject("âŒ Something went wrong!");
  }
});

myPromise
  .then((message) => {
    console.log("Then:", message);
  })
  .catch((error) => {
    console.log("Catch:", error);
  });

Output (if success = true):
Then: âœ… Task done successfully!

Output (if success = false):
Catch: âŒ Something went wrong!


ðŸ§  Explanation:

resolve() â†’ when the task completes successfully

reject() â†’ when thereâ€™s an error

.then() â†’ handles success

.catch() â†’ handles errors

âš™ï¸ 4. async / await

What it does:
async and await make working with Promises easier and cleaner â€” like synchronous code but still asynchronous under the hood.

Example:
function getData() {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve("ðŸ“¦ Data received after 2 seconds");
    }, 2000);
  });
}

async function showData() {
  console.log("Fetching data...");
  const data = await getData(); // waits for Promise to resolve
  console.log(data);
  console.log("Done!");
}

showData();

Output:
Fetching data...
ðŸ“¦ Data received after 2 seconds
Done!


ðŸ§  Explanation:

async â†’ makes a function return a Promise

await â†’ waits until the Promise resolves before moving to the next line

This avoids callback hell and makes your code more readable.


 #### #### some problems related to async await and their solutions with explainations 










 Example 1: Wait before printing

ðŸ‘‰ Problem:
Write an async function that waits for 2 seconds, then prints "Hello after 2 seconds".

âœ… Solution:
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function greet() {
  console.log("Waiting...");
  await delay(2000); // waits for 2 seconds
  console.log("Hello after 2 seconds");
}

greet();

ðŸ§  Explanation:

delay(ms) â†’ returns a promise that resolves after given time.

await delay(2000) â†’ pauses the async function for 2 seconds.

After that, "Hello after 2 seconds" is printed.

âš™ï¸ Example 2: Returning values from async

ðŸ‘‰ Problem:
Make an async function that returns "Data fetched" after 1 second.

âœ… Solution:
async function fetchData() {
  return new Promise(resolve => {
    setTimeout(() => resolve("Data fetched"), 1000);
  });
}

async function main() {
  const result = await fetchData();
  console.log(result);
}

main();

ðŸ§  Explanation:

The async function fetchData() returns a promise.

We await it in main(), and it logs "Data fetched" after 1 second.

âš¡ Example 3: Sequential vs Parallel Execution

ðŸ‘‰ Problem:
Run 3 tasks â€” task1, task2, and task3 â€” both sequentially and parallelly.

âœ… Solution:
function task1() {
  return new Promise(resolve => setTimeout(() => resolve("Task 1 done"), 2000));
}
function task2() {
  return new Promise(resolve => setTimeout(() => resolve("Task 2 done"), 1000));
}
function task3() {
  return new Promise(resolve => setTimeout(() => resolve("Task 3 done"), 3000));
}

async function runSequential() {
  console.time("Sequential");
  console.log(await task1());
  console.log(await task2());
  console.log(await task3());
  console.timeEnd("Sequential");
}

async function runParallel() {
  console.time("Parallel");
  const results = await Promise.all([task1(), task2(), task3()]);
  console.log(results);
  console.timeEnd("Parallel");
}

runSequential().then(runParallel);

ðŸ§  Explanation:

Sequential: each await waits for the previous one â†’ slower.

Parallel: Promise.all() runs all tasks together â†’ faster ðŸš€






ðŸŒ Example 4: Fetch API using async/await

ðŸ‘‰ Problem:
Fetch and display all user names from
https://jsonplaceholder.typicode.com/users

âœ… Solution:
async function getUsers() {
  const response = await fetch("https://jsonplaceholder.typicode.com/users");
  const data = await response.json();
  
  data.forEach(user => console.log(user.name));
}

getUsers();

ðŸ§  Explanation:

fetch() returns a promise â†’ we await the response.

response.json() converts it to JS object â†’ again await.

Then we print names using forEach.




ðŸ’¥ Example 5: Error handling with try...catch
ðŸ‘‰ Problem:
Fetch data from an invalid URL and handle the error.

âœ… Solution:
async function getData() {
  try {
    const response = await fetch("https://invalid-url.com/data");
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.log("Something went wrong!", error.message);
  }
}


getData();

ðŸ§  Explanation:

If fetch() fails, control goes to catch block.

You can handle network failures or API issues gracefully.



one more problem .... 

Example 6: Login â†’ Fetch Posts â†’ Display

ðŸ‘‰ Problem:
Simulate a flow where:

A user logs in (takes 1 second).

After login, fetch that userâ€™s posts (takes 2 seconds).

Then display those posts (takes 1 second).

You need to use async/await and Promises to make it work step-by-step.

âœ… Solution:
function loginUser(username) {
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log("âœ… User logged in:", username);
      resolve({ username });
    }, 1000);
  });
}

function getUserPosts(username) {
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log("ðŸ“© Fetching posts for:", username);
      resolve(["Post 1", "Post 2", "Post 3"]);
    }, 2000);
  });
}

function displayPosts(posts) {
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log("ðŸ–¥ï¸ Displaying posts:");
      posts.forEach(post => console.log("â€¢", post));
      resolve();
    }, 1000);
  });
}

async function main() {
  const user = await loginUser("RohitBhai");
  const posts = await getUserPosts(user.username);
  await displayPosts(posts);
  console.log("âœ… All tasks completed!");
}

main();

ðŸ§  Explanation:

loginUser() waits 1 sec â†’ returns a user object.

getUserPosts() waits 2 sec â†’ returns an array of posts.

displayPosts() waits 1 sec â†’ prints posts.

await ensures each step runs in order, like real-world API calls.
