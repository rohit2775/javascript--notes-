
  ####### all array methods ....... 
 

1. Array Creation & Checking
üîπ Array.isArray(value)

Use: Checks whether the given value is an array or not.
Useful because in JavaScript, many things are objects, so this confirms if it‚Äôs an actual array.

Array.isArray([1,2,3]); // true ‚úÖ
Array.isArray("Rohit"); // false ‚ùå


üìò Use case: When you receive data from API or user input and want to ensure it‚Äôs an array.

üîπ Array.from(object)

Use: Converts array-like or iterable objects (like strings, NodeList, Set, etc.) into a real array.

Array.from("Rohit"); 
// Output: ['R','o','h','i','t']


üìò Use case:
When you select multiple DOM elements (document.querySelectorAll()), it returns NodeList (not an array).
Use Array.from() to convert it so you can use map(), filter(), etc.

üîπ Array.of(...items)

Use: Creates a new array from the provided arguments.

Array.of(1,2,3); 
// Output: [1,2,3]


üìò Use case:
When you want to dynamically create an array from a list of values.

‚ûï 2. Add / Remove Elements
üîπ push(element)

Use: Adds an element to the end of the array.

let arr = [1,2];
arr.push(3);
console.log(arr); // [1,2,3]


üìò Real-life example: Adding an item to a shopping cart.

üîπ pop()

Use: Removes the last element from the array.

arr.pop();
console.log(arr); // [1,2]


üìò Real-life example: Removing the last item added to a cart.

üîπ unshift(element)

Use: Adds an element to the start of the array.

arr.unshift(0);
console.log(arr); // [0,1,2]


üìò Real-life example: Adding a person at the start of a queue.

üîπ shift()

Use: Removes the first element from the array.

arr.shift();
console.log(arr); // [1,2]


üìò Real-life example: Serving the first person in a queue.

üîπ splice(start, deleteCount, ...items)

Use: Can add, remove, or replace elements at any position.
‚ö†Ô∏è This modifies the original array.

let arr2 = [1,2,3,4];
arr2.splice(1,2,99); 
console.log(arr2); // [1,99,4]


Explanation:

1 ‚Üí start index

2 ‚Üí number of elements to delete

99 ‚Üí element to insert

üîπ slice(start, end)

Use: Returns a copy of a portion of an array (does not change original).

let newArr = [10,20,30,40].slice(1,3);
console.log(newArr); // [20,30]


üìò Use case: Getting a part of an array for pagination.

üîπ concat()

Use: Combines two or more arrays into a new array.

let merged = [1,2].concat([3,4]);
console.log(merged); // [1,2,3,4]


üìò Use case: Combining different sets of data.

üîç 3. Searching & Checking Elements
üîπ indexOf(value)

Use: Returns the first index of the element. Returns -1 if not found.

[1,2,3,2].indexOf(2); // 1

üîπ lastIndexOf(value)

Use: Returns the last index of the element.

[1,2,3,2].lastIndexOf(2); // 3

üîπ includes(value)

Use: Checks if the element exists in the array. Returns true/false.

[1,2,3].includes(2); // true


üìò Use case: Validating if a user input or value already exists.

üîπ find(callback)

Use: Returns the first element that satisfies a condition.

let num = [10,20,30].find(x => x > 15);
console.log(num); // 20

üîπ findIndex(callback)

Use: Returns the index of the first element that satisfies a condition.

[10,20,30].findIndex(x => x > 15); // 1

üîπ every(callback)

Use: Checks if all elements satisfy the condition.

[2,4,6].every(x => x % 2 === 0); // true

üîπ some(callback)

Use: Checks if any element satisfies the condition.

[1,2,3].some(x => x > 2); // true

üîÅ 4. Looping / Iteration
üîπ forEach(callback)

Use: Executes a function for each element, but does not return anything.

[1,2,3].forEach(x => console.log(x * 2));

üîπ map(callback)

Use: Applies a function on each element and returns a new array.

let doubled = [1,2,3].map(x => x * 2);
console.log(doubled); // [2,4,6]

üîπ filter(callback)

Use: Returns a new array of elements that satisfy a condition.

let even = [1,2,3,4].filter(x => x % 2 === 0);
console.log(even); // [2,4]

üîπ reduce(callback, initialValue)

Use: Combines all elements into a single value.

let sum = [1,2,3,4].reduce((total, x) => total + x, 0);
console.log(sum); // 10


üìò Real-life: Calculating total price in a cart.

üîπ reduceRight(callback)

Use: Same as reduce, but runs from right to left.

[1,2,3].reduceRight((a,b)=>a-b); // 0

üîÑ 5. Sorting / Reversing
üîπ sort(compareFn)

Use: Sorts elements of an array. Default is string sorting, so for numbers, use a compare function.

let nums = [40,10,30];
nums.sort((a,b) => a - b);
console.log(nums); // [10,30,40]

üîπ reverse()

Use: Reverses the order of elements.

[1,2,3].reverse(); // [3,2,1]



 if want  to better understand in hindi .... 



 1. Array Creation & Checking
üîπ Array.isArray(value)

Use: Ye check karta hai ki jo value di gayi hai wo array hai ya nahi.
Kyunki JS me sab kuch object hota hai, isse sure karne ke liye ye method use hota hai.

Array.isArray([1,2,3]); // true  ‚úÖ ye ek array hai
Array.isArray("Rohit"); // false ‚ùå ye ek string hai


üìò Use case:
Jab API ya user se data mile, aur tumhe check karna ho ki wo array hai ya single value.

üîπ Array.from(object)

Use: Ye kisi bhi array-like ya iterable object (like string, NodeList, Set, etc.) ko array me convert karta hai.

Array.from("Rohit"); 
// Output: ['R','o','h','i','t']


üìò Use case:
DOM me jab hum document.querySelectorAll() se NodeList nikalte hain, wo array nahi hota.
Use Array.from() se array me convert karte hain taaki hum map(), filter() use kar sakein.

üîπ Array.of(...items)

Use: Ye given arguments se ek naya array banata hai.

Array.of(1,2,3); 
// Output: [1,2,3]


üìò Use case:
Jab hume dynamically elements se array banana ho bina kisi type confusion ke.

‚ûï 2. Add / Remove Elements
üîπ push(element)

Use: Ye array ke end me ek element add karta hai.

let arr = [1,2];
arr.push(3);
console.log(arr); // [1,2,3]


üìò Real-life: Shopping cart me item add karna.

üîπ pop()

Use: Ye last element remove karta hai.

arr.pop();
console.log(arr); // [1,2]


üìò Real-life: Cart se last added product remove karna.

üîπ unshift(element)

Use: Ye array ke start me element add karta hai.

arr.unshift(0);
console.log(arr); // [0,1,2]


üìò Real-life: Queue ke starting me new entry lagana.

üîπ shift()

Use: Ye first element remove karta hai.

arr.shift();
console.log(arr); // [1,2]


üìò Real-life: Queue ke first person ko remove karna (kaam ho gaya üòÑ).

üîπ splice(start, deleteCount, ...items)

Use: Ye elements ko remove, replace ya add kar sakta hai.
‚ö†Ô∏è Original array change karta hai.

let arr2 = [1,2,3,4];
arr2.splice(1,2,99); 
console.log(arr2); // [1,99,4]


üìò Explanation:

1 ‚Üí start index

2 ‚Üí deleteCount

99 ‚Üí new element
So index 1 aur 2 delete hue (2,3) aur 99 add hua.

üîπ slice(start, end)

Use: Array ke ek portion ka copy return karta hai (original change nahi hoti).

let newArr = [10,20,30,40].slice(1,3);
console.log(newArr); // [20,30]


üìò Use case: Jab array ka ek part chahiye ho ‚Äî jaise pagination me.

üîπ concat()

Use: 2 ya zyada arrays ko combine karta hai.

let merged = [1,2].concat([3,4]);
console.log(merged); // [1,2,3,4]


üìò Use case: Different arrays ka combined data chahiye.

üîç 3. Searching & Checking Elements
üîπ indexOf(value)

Use: Element ka first index batata hai. Agar nahi milta to -1.

[1,2,3,2].indexOf(2); // 1

üîπ lastIndexOf(value)

Use: Element ka last index batata hai.

[1,2,3,2].lastIndexOf(2); // 3

üîπ includes(value)

Use: Check karta hai ki array me wo value hai ya nahi (true/false).

[1,2,3].includes(2); // true


üìò Use case: Validation ke liye ‚Äî e.g. check if user input already exists.

üîπ find(callback)

Use: Pehla element return karta hai jo condition ko satisfy karta hai.

let num = [10,20,30].find(x => x > 15);
console.log(num); // 20

üîπ findIndex(callback)

Use: Pehle matching element ka index return karta hai.

[10,20,30].findIndex(x => x > 15); // 1

üîπ every(callback)

Use: Check karta hai sabhi elements condition pass kar rahe hain ya nahi.

[2,4,6].every(x => x % 2 === 0); // true

üîπ some(callback)

Use: Check karta hai ki koi ek element bhi condition pass karta hai ya nahi.

[1,2,3].some(x => x > 2); // true

üîÅ 4. Looping / Iteration
üîπ forEach(callback)

Use: Har element par function execute karta hai, but return nahi karta.

[1,2,3].forEach(x => console.log(x * 2));

üîπ map(callback)

Use: Har element par function apply karta hai aur new array return karta hai.

let doubled = [1,2,3].map(x => x * 2);
console.log(doubled); // [2,4,6]

üîπ filter(callback)

Use: Jo elements condition pass karte hain, unka naya array banata hai.

let even = [1,2,3,4].filter(x => x % 2 === 0);
console.log(even); // [2,4]

üîπ reduce(callback, initialValue)

Use: Array ke sabhi elements ko combine karke ek single value return karta hai.

let sum = [1,2,3,4].reduce((total, x) => total + x, 0);
console.log(sum); // 10


üìò Real-life: Bill me total price calculate karna.

üîπ reduceRight(callback)

Use: Same as reduce, lekin right to left kaam karta hai.

[1,2,3].reduceRight((a,b)=>a-b); // 0

üîÑ 5. Sorting / Reversing
üîπ sort(compareFn)

Use: Array ke elements ko sort karta hai (default string wise).
Numerical sorting ke liye compareFn zaroor likhna hota hai.

let nums = [40,10,30];
nums.sort((a,b) => a - b);
console.log(nums); // [10,30,40]

üîπ reverse()

Use: Array ko ulta kar deta hai.

[1,2,3].reverse(); // [3,2,1]




 ####### objects in js 

 What is an Object?

English:
An object is a collection of key-value pairs.
Keys are usually strings (or symbols), and values can be anything: numbers, strings, arrays, functions, or even other objects.
Objects allow you to group related data together.

let student = {
    name: "Rohit",
    age: 18,
    marks: [85, 90, 95],
    isActive: true
};



2Ô∏è‚É£ Accessing Properties

Dot Notation

console.log(student.name); // "Rohit"


Bracket Notation (useful when key is dynamic)

console.log(student["age"]); // 18

let key = "marks";
console.log(student[key]); // [85, 90, 95]

3Ô∏è‚É£ Adding or Updating Properties
// Add a new property
student.gender = "Male";

// Update existing property
student.age = 19;

console.log(student);
// { name: 'Rohit', age: 19, marks: [85,90,95], isActive: true, gender: 'Male' }

4Ô∏è‚É£ Deleting Properties
delete student.isActive;
console.log(student);
// { name: 'Rohit', age: 19, marks: [85,90,95], gender: 'Male' }

5Ô∏è‚É£ Methods in Objects

English: Methods are functions inside objects. They usually operate on the object‚Äôs data using this.

let student = {
    name: "Rohit",
    age: 18,
    greet: function() {
        console.log(`Hello, my name is ${this.name}`);
    }
};

student.greet(); // "Hello, my name is Rohit"


6Ô∏è‚É£ Built-in Object Methods
1. Object.keys(obj) ‚Üí Returns all keys
console.log(Object.keys(student)); // ["name","age","greet"]

2. Object.values(obj) ‚Üí Returns all values
console.log(Object.values(student)); // ["Rohit", 18, function greet(){}]

3. Object.entries(obj) ‚Üí Returns array of [key, value] pairs
console.log(Object.entries(student));
// [["name","Rohit"], ["age",18], ["greet", function(){}]]

4. Object.assign(target, ...sources) ‚Üí Copies properties from sources to target
let obj1 = {a:1, b:2};
let obj2 = {b:3, c:4};
Object.assign(obj1, obj2);
console.log(obj1); // {a:1, b:3, c:4}

5. Object.freeze(obj) ‚Üí Makes object immutable (cannot add/update/delete)
Object.freeze(student);
student.age = 20; // won't work
student.city = "Delhi"; // won't work

6. Object.seal(obj) ‚Üí Allows modifying existing properties but cannot add/delete
Object.seal(student);
student.age = 25; // works
student.city = "Delhi"; // doesn't work

7. Object.hasOwn(obj, prop) ‚Üí Checks if object has its own property (not inherited)
console.log(Object.hasOwn(student, 'name')); // true
console.log(Object.hasOwn(student, 'toString')); // false

8. Object.getOwnPropertyNames(obj) ‚Üí Returns all property names (enumerable + non-enumerable)
console.log(Object.getOwnPropertyNames(student));

7Ô∏è‚É£ Looping through Objects
for (let key in student) {
    console.log(key, student[key]);
}
// name Rohit
// age 18
// greet function()...

8Ô∏è‚É£ Mini Example
let student = {
    name: "Rohit",
    age: 18,
    marks: [85,90],
    greet() { console.log(`Hi, I'm ${this.name}`); }
};

// Access
console.log(student.name);

// Add / Update
student.gender = "Male";
student.age = 19;

// Delete
delete student.marks;

// Object methods
console.log(Object.keys(student)); // ['name','age','greet','gender']
console.log(Object.values(student)); // ['Rohit',19,function,'Male']

// Loop
for(let key in student) {
    console.log(key, student[key]);
}

// Method call
student.greet(); // Hi, I'm Rohit



 now  lets understand in hindi 


 Object kya hai?

Hindi:
Object ek key-value pair ka collection hota hai.
Keys usually strings (ya symbols) hoti hain, aur values kuch bhi ho sakti hain: numbers, strings, arrays, functions, ya dusre objects.
Objects hume related data ko ek saath organize karne me help karte hain.

let student = {
    name: "Rohit",
    age: 18,
    marks: [85, 90, 95],
    isActive: true
};

2Ô∏è‚É£ Object ki properties access karna

Dot Notation / Dot se access

console.log(student.name); // "Rohit"


Bracket Notation / Brackets se access (jab key dynamic ho)

console.log(student["age"]); // 18

let key = "marks";
console.log(student[key]); // [85, 90, 95]

3Ô∏è‚É£ Properties add ya update karna
// Nayi property add karna
student.gender = "Male";

// Existing property update karna
student.age = 19;

console.log(student);
// { name: 'Rohit', age: 19, marks: [85,90,95], isActive: true, gender: 'Male' }

4Ô∏è‚É£ Properties delete karna
delete student.isActive;
console.log(student);
// { name: 'Rohit', age: 19, marks: [85,90,95], gender: 'Male' }

5Ô∏è‚É£ Object Methods / Object me functions

Hindi: Methods wo functions hote hain jo object ke andar define hote hain.

Usually this ka use object ke data ko access karne ke liye hota hai.

let student = {
    name: "Rohit",
    age: 18,
    greet: function() {
        console.log(`Hello, mera naam hai ${this.name}`);
    }
};

student.greet(); // "Hello, mera naam hai Rohit"

6Ô∏è‚É£ Built-in Object Methods / Inbuilt methods
1Ô∏è‚É£ Object.keys(obj) ‚Üí Sab keys ka array return karta hai
console.log(Object.keys(student)); // ["name","age","greet"]

2Ô∏è‚É£ Object.values(obj) ‚Üí Sab values ka array return karta hai
console.log(Object.values(student)); // ["Rohit", 18, function greet(){}]

3Ô∏è‚É£ Object.entries(obj) ‚Üí [key, value] pairs ka array return karta hai
console.log(Object.entries(student));
// [["name","Rohit"], ["age",18], ["greet", function(){}]]

4Ô∏è‚É£ Object.assign(target, ...sources) ‚Üí Ek ya zyada source objects ki properties target me copy karta hai
let obj1 = {a:1, b:2};
let obj2 = {b:3, c:4};
Object.assign(obj1, obj2);
console.log(obj1); // {a:1, b:3, c:4}

5Ô∏è‚É£ Object.freeze(obj) ‚Üí Object ko immutable bana deta hai (add/update/delete nahi kar sakte)
Object.freeze(student);
student.age = 20; // kaam nahi karega
student.city = "Delhi"; // kaam nahi karega

6Ô∏è‚É£ Object.seal(obj) ‚Üí Existing properties modify kar sakte ho, lekin new property add/delete nahi kar sakte
Object.seal(student);
student.age = 25; // kaam karega
student.city = "Delhi"; // kaam nahi karega

7Ô∏è‚É£ Object.hasOwn(obj, prop) ‚Üí Check karta hai ki property object ki apni hai ya inherited
console.log(Object.hasOwn(student, 'name')); // true
console.log(Object.hasOwn(student, 'toString')); // false

8Ô∏è‚É£ Object.getOwnPropertyNames(obj) ‚Üí Sab property names (enumerable + non-enumerable) ka array return karta hai
console.log(Object.getOwnPropertyNames(student));

7Ô∏è‚É£ Object loop / Object me loop lagana
for (let key in student) {
    console.log(key, student[key]);
}
// name Rohit
// age 18
// greet function()...

8Ô∏è‚É£ Mini Example ‚Äî Objects + Methods
let student = {
    name: "Rohit",
    age: 18,
    marks: [85,90],
    greet() { console.log(`Hi, mai ${this.name} hu`); }
};

// Access
console.log(student.name);

// Add / Update
student.gender = "Male";
student.age = 19;

// Delete
delete student.marks;

// Object methods
console.log(Object.keys(student)); // ['name','age','greet','gender']
console.log(Object.values(student)); // ['Rohit',19,function,'Male']

// Loop
for(let key in student) {
    console.log(key, student[key]);
}

// Method call
student.greet(); // Hi, mai Rohit hu




.. #### import and export 

   What are import and export in JavaScript?

When we build big projects, we split our code into multiple files so that everything stays clean, readable, and easy to manage.
This is called modular coding.

Now, if you write a function, variable, or class in one file
and want to use it in another file,
you‚Äôll use export (to send it out) and import (to bring it in).

üîπ 1. Export ‚Äî sending code out of a file
(a) Named Export

You can export multiple things from a file, each with its own name.

// file: math.js
export const PI = 3.14;

export function add(a, b) {
  return a + b;
}

export function subtract(a, b) {
  return a - b;
}


Now, to use them in another file üëá

// file: app.js
import { PI, add, subtract } from './math.js';

console.log(PI); // 3.14
console.log(add(5, 3)); // 8
console.log(subtract(5, 3)); // 2


The curly braces {} mean you‚Äôre importing named exports by their names.

(b) Default Export

If you want to export only one main thing from a file,
use export default.

// file: greet.js
export default function greet(name) {
  return `Hello, ${name}!`;
}


Now import it üëá

// file: app.js
import greet from './greet.js';

console.log(greet('Rohit')); // Hello, Rohit!


‚ö° Here, you don‚Äôt need {} because it‚Äôs a default export.

üîπ 2. Import ‚Äî bringing code into a file

When you want to use code from another file, you import it.

Example üëá

import { add } from './math.js';
import greet from './greet.js';

console.log(add(2, 3)); // 5
console.log(greet('Rohit')); // Hello, Rohit!

üß† Important Tips to Remember
Type	           Syntax	                          Example
Named Export	   export const name = ...	             export function add() {}
Default Export	   export default ...	                 export default function() {}
Named Import	   import { name } from '...'	         import { add } from './math.js'
Default Import	   import name from '...'	             import greet from './greet.js'
Rename Import	   import { add as plus } from '...'	  plus(2, 3)


üì¶ Real-World Example

Let‚Äôs say you have a utils.js file that contains some useful functions üëá

// utils.js
export function formatName(name) {
  return name.toUpperCase();
}

export default function sayHi(name) {
  console.log(`Hi, ${name}!`);
}


Now you can import and use them in your main file üëá

// main.js
import sayHi, { formatName } from './utils.js';

const name = formatName('rohit');
sayHi(name); // Hi, ROHIT!


In simple words üëá

üî∏ export = send something out of a file
üî∏ import = bring something into a file




  lets get started with the asynchronous javascript 

    for andeling API's delays, and  fretching data we have to use asynchronous javascript 
    like promises , async await etc 


    setTimeout() and setInterval()
    Promise (resolve, reject, then, catch)
    async / await
    fetch() API (for making requests)


    setTimeout()

What it does:
setTimeout() runs a piece of code after a delay (in milliseconds) ‚Äî and it runs only once.

Example:
console.log("Start");

setTimeout(() => {
  console.log("Hello Rohit after 2 seconds!");
}, 2000); // 2000 ms = 2 seconds

console.log("End");

Output:
Start
End
Hello Rohit after 2 seconds!


üß† Explanation:
setTimeout() is asynchronous ‚Äî it doesn‚Äôt block other code.
The rest of the program continues running, and after the given delay, your callback runs.

üîÅ 2. setInterval()

What it does:
setInterval() repeatedly runs a function every X milliseconds until you stop it.

Example:
let count = 0;

const intervalId = setInterval(() => {
  count++;
  console.log("Count:", count);

  if (count === 5) {
    clearInterval(intervalId); // stop after 5 times
  }
}, 1000); // run every 1 second

Output:
Count: 1
Count: 2
Count: 3
Count: 4
Count: 5


üß† Explanation:

setInterval() runs repeatedly

Use clearInterval(id) to stop it.

üíé 3. Promise

What it does:
A Promise is an object that represents a value that may be available now, later, or never.
It‚Äôs used to handle asynchronous tasks like API calls or reading files.

A Promise has 3 states:

pending

fulfilled (resolved)

rejected

Example:
let myPromise = new Promise((resolve, reject) => {
  let success = true; // try changing to false to test rejection

  if (success) {
    resolve("‚úÖ Task done successfully!");
  } else {
    reject("‚ùå Something went wrong!");
  }
});

myPromise
  .then((message) => {
    console.log("Then:", message);
  })
  .catch((error) => {
    console.log("Catch:", error);
  });

Output (if success = true):
Then: ‚úÖ Task done successfully!

Output (if success = false):
Catch: ‚ùå Something went wrong!


üß† Explanation:

resolve() ‚Üí when the task completes successfully

reject() ‚Üí when there‚Äôs an error

.then() ‚Üí handles success

.catch() ‚Üí handles errors

‚öôÔ∏è 4. async / await

What it does:
async and await make working with Promises easier and cleaner ‚Äî like synchronous code but still asynchronous under the hood.

Example:
function getData() {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve("üì¶ Data received after 2 seconds");
    }, 2000);
  });
}

async function showData() {
  console.log("Fetching data...");
  const data = await getData(); // waits for Promise to resolve
  console.log(data);
  console.log("Done!");
}

showData();

Output:
Fetching data...
üì¶ Data received after 2 seconds
Done!


üß† Explanation:

async ‚Üí makes a function return a Promise

await ‚Üí waits until the Promise resolves before moving to the next line

This avoids callback hell and makes your code more readable.


 #### #### some problems related to async await and their solutions with explainations 










 Example 1: Wait before printing

üëâ Problem:
Write an async function that waits for 2 seconds, then prints "Hello after 2 seconds".

‚úÖ Solution:
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function greet() {
  console.log("Waiting...");
  await delay(2000); // waits for 2 seconds
  console.log("Hello after 2 seconds");
}

greet();

üß† Explanation:

delay(ms) ‚Üí returns a promise that resolves after given time.

await delay(2000) ‚Üí pauses the async function for 2 seconds.

After that, "Hello after 2 seconds" is printed.

‚öôÔ∏è Example 2: Returning values from async

üëâ Problem:
Make an async function that returns "Data fetched" after 1 second.

‚úÖ Solution:
async function fetchData() {
  return new Promise(resolve => {
    setTimeout(() => resolve("Data fetched"), 1000);
  });
}

async function main() {
  const result = await fetchData();
  console.log(result);
}

main();

üß† Explanation:

The async function fetchData() returns a promise.

We await it in main(), and it logs "Data fetched" after 1 second.

‚ö° Example 3: Sequential vs Parallel Execution

üëâ Problem:
Run 3 tasks ‚Äî task1, task2, and task3 ‚Äî both sequentially and parallelly.

‚úÖ Solution:
function task1() {
  return new Promise(resolve => setTimeout(() => resolve("Task 1 done"), 2000));
}
function task2() {
  return new Promise(resolve => setTimeout(() => resolve("Task 2 done"), 1000));
}
function task3() {
  return new Promise(resolve => setTimeout(() => resolve("Task 3 done"), 3000));
}

async function runSequential() {
  console.time("Sequential");
  console.log(await task1());
  console.log(await task2());
  console.log(await task3());
  console.timeEnd("Sequential");
}

async function runParallel() {
  console.time("Parallel");
  const results = await Promise.all([task1(), task2(), task3()]);
  console.log(results);
  console.timeEnd("Parallel");
}

runSequential().then(runParallel);

üß† Explanation:

Sequential: each await waits for the previous one ‚Üí slower.

Parallel: Promise.all() runs all tasks together ‚Üí faster üöÄ






üåê Example 4: Fetch API using async/await

üëâ Problem:
Fetch and display all user names from
https://jsonplaceholder.typicode.com/users

‚úÖ Solution:
async function getUsers() {
  const response = await fetch("https://jsonplaceholder.typicode.com/users");
  const data = await response.json();
  
  data.forEach(user => console.log(user.name));
}

getUsers();

üß† Explanation:

fetch() returns a promise ‚Üí we await the response.

response.json() converts it to JS object ‚Üí again await.

Then we print names using forEach.




üí• Example 5: Error handling with try...catch
üëâ Problem:
Fetch data from an invalid URL and handle the error.

‚úÖ Solution:
async function getData() {
  try {
    const response = await fetch("https://invalid-url.com/data");
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.log("Something went wrong!", error.message);
  }
}


getData();

üß† Explanation:

If fetch() fails, control goes to catch block.

You can handle network failures or API issues gracefully.



one more problem .... 

Example 6: Login ‚Üí Fetch Posts ‚Üí Display

üëâ Problem:
Simulate a flow where:

A user logs in (takes 1 second).

After login, fetch that user‚Äôs posts (takes 2 seconds).

Then display those posts (takes 1 second).

You need to use async/await and Promises to make it work step-by-step.

‚úÖ Solution:
function loginUser(username) {
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log("‚úÖ User logged in:", username);
      resolve({ username });
    }, 1000);
  });
}

function getUserPosts(username) {
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log("üì© Fetching posts for:", username);
      resolve(["Post 1", "Post 2", "Post 3"]);
    }, 2000);
  });
}

function displayPosts(posts) {
  return new Promise((resolve) => {
    setTimeout(() => {
      console.log("üñ•Ô∏è Displaying posts:");
      posts.forEach(post => console.log("‚Ä¢", post));
      resolve();
    }, 1000);
  });
}

async function main() {
  const user = await loginUser("RohitBhai");
  const posts = await getUserPosts(user.username);
  await displayPosts(posts);
  console.log("‚úÖ All tasks completed!");
}

main();

üß† Explanation:

loginUser() waits 1 sec ‚Üí returns a user object.

getUserPosts() waits 2 sec ‚Üí returns an array of posts.

displayPosts() waits 1 sec ‚Üí prints posts.

await ensures each step runs in order, like real-world API calls.
